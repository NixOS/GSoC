# Ideas

Welcome to our Google Summer of Code ideas list!

## small (90 hours)

### Nix cleanup: merge `ParsedDerivation` into `BasicDerivation`, improve JSON format

Nix currently special-cases some environment variables in derivations to convey extra meaning ("system features", "prefer local build", etc.).
We're stuck with this in the [`.drv` A-Term format](https://nixos.org/manual/nix/stable/protocols/derivation-aterm) and `builtins.derivation` because of backwards compatibility requirements, but that doesn't mean our internal data structures and (currently experimental, i.e. not yet stabilized and immobile) JSON format cannot be improved.

This project would be about doing just that: Fix the internal data structures, and then use that refactor to make the JSON format better.

As a stretch goal, we can then start proposing/prototyping a worthy successor to `builtins.derivation` that would better support this stuff.
(C.f. the "structured attrs" work in Nixpkgs.)

See https://github.com/NixOS/nix/issues/9846
and https://github.com/NixOS/nix/issues/9866.

Possible mentors:
- [@Ericson2314](https://github.com/Ericson2314)

### nixpkgs library networking functions

Many things in NixOS use the Internet Protocol and other network related technologies, thus a lot of modules and service have to deal with them.
Currently this is mostly done just passing strings as arguments, but it would be a lot more convenient to have things like `lib.types.ipv6`, `lib.types.ipv4` and other functions to for example convert between cidr notation and the bit representation of netmasks.
Some inspiration for functions can be drawn from similar libraries like the [python ipaddress lib](https://github.com/python/cpython/blob/3.12/Lib/ipaddress.py)
This would not just be useful for NixOS it self but also for its users since a lot of folks use it to power network appliances and build infrastructure on top of it.

Skills required/preferred:
Some prior networking knowledge would be useful but is not required. Prior knowledge of the nix programming language is not required, any new-comer wanting to pick this up should easily be able to complete a nix tutorial like [a tour of Nix](https://nixcloud.io/tour/?id=introduction/nix) in one or two afternoons and be good to go.

Possible mentors:
- [@Janik-Haag](https://github.com/Janik-Haag)

Rating:
medium

Prior efforts:
there was some prior efforts in [nixpkgs#258250](https://github.com/NixOS/nixpkgs/pull/258250) but it is stuck for a few months now and also only adds function for legacy ip, it's also quite bare bones and we might want some more advanced things like a function to check if a ip matches a given subnet.

### First class support for Crystal applications

Currently, our support for applications written in crystal consists of 2 main pieces:

1. `crystal2nix` for converting lock files created by the `shards` tool to nix.
2. the nixpkgs build infrastructure that supports a range of different means to build crystal applications (incl consuming the outputs of item 1).
   
The existing support is brittle and unpleasant to read and only supports dependencies fetched via git. 

This project would be interesting as it touches several different types of projects:

1. redesigning the build infrastructure to be easier to hack on (nixpkgs)
2. implementing the new build infrastructure (nixpkgs)
3. extending the `crystal2nix` tool to understand other VCSs (crystal2nix)

Skills preferred:
a. nix and bash for the build infrastructure
b. crystal or ruby for `crystal2nix` (if you know ruby, you know crystal)

Possible Mentors:
- [@peterhoeg](https://github.com/peterhoeg)

Difficulty:
easy

Prior efforts:
We have both working crystal build infrastructure as well as a working [crystal2nix](https://github.com/nix-community/crystal2nix), so you will not be starting from scratch.

### Centralized on-failure reporting for failed systemd units

A systemd service supports triggering another unit if it fails through the `OnFailure` option. In NixOS we have centralized configuration and yet no way to easily opt in to common/shared `OnFailure` handlers. 

With such infrastructure in place, it becomes trivial to have hosts react properly to failure and outages in addition to whatever other monitoring might be in place. 

This project consist of a few different items:

1. mapping out and understanding the various failure modes that running software is exposed to
2. implementing both the common NixOS infrastructure but also various types of handlers that will react to failures
3. test infrastructure through NixOS tests for verification

Skills preferred:
a. basic nix for NixOS modules

Possible mentors:
- [@peterhoeg](https://github.com/peterhoeg)
  
Rating:
easy
  
Prior efforts:
We have [boot counting](https://github.com/NixOS/nixpkgs/pull/273062) that is one part of the puzzle and with what we would want to integrate the standard failure handlers.

## medium (175 hours)

### Nix Internals: Use `std::filesystem::path` for `Path`

Nix currently has a bunch of home-grown file system and file path utilities.
However in recent years ([C++17](https://en.wikipedia.org/wiki/C%2B%2B17#Language)) the standard library has gained a new [`std::fileystem`](https://en.cppreference.com/w/cpp/filesystem) library which has much of the same functionality.

The purpose of this project is to use `std::filesystem` where possible, with a particular emphasis on using the `std::filesystem::path` type rather than our own `Path` (which is just an alias for `std::string`).

This shrinks Nix (no need to maintain redundant code!), and will also aid in porting Nix to Windows, since an explicit design goal of `std::filesystem` is to be portable between Unix and Windows.

See https://github.com/NixOS/nix/issues/9205 for details.

Possible mentors:
 - [@Ericson2314](https://github.com/Ericson2314)

### nixpkgs pnpm tooling

pnpm is a package manager that claims to be up to 2x faster than npm and more efficient than npm when it comes to disk space usage, because of this benefits more and more projects are using pnpm.
We have tooling for the npm but it's mostly incompatible, this is leading to hacky workarounds and makes packaging pnpm projects a pain.
If you decide to work on this project you will gain a lot of knowledge about the gears that make nixpkgs turn, namely things like setup hooks and fetcher.

Skills required/preferred:
Having experience with javascript/frontend tooling like nodejs would most certainly be a plus.

Possible mentors:
- [@Kranzes](https://github.com/Kranzes)
- [@Janik-Haag](https://github.com/Janik-Haag)

Rating:
hard

Prior efforts:
There is a tool called [pnpm2nix](https://github.com/nix-community/pnpm2nix/) but it didn't get updates in a few years because of [pnpm#1035](https://github.com/pnpm/pnpm/issues/1035), this should be a non problem for us if we use a fod fetcher like the nixpkgs npm tooling.
Some packages use [a fetcher]((https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/applications/misc/pot/default.nix#L43)) without strong reproducibility guarantees.

## large (350 hours)

### outpath cache for faster automation

[OfBorg](https://github.com/nixos/ofborg) and [nixpkgs-update](https://github.com/ryantm/nixpkgs-update) rely on a tool that calculates the output directories for every derivation in the top level of nixpkgs. The tool is run before and after a change to detect how many packages will be affected by the change. It is currently *very slow*. In fact, it is probably about 80% of the total computation nixpkgs-update does. This project would be to cache information about what kind of edits affect other derivations, or statically determine it in a faster way than calculating the outpath of every derivation. A successful project would speed up OfBorg and/or nixpkgs-update significantly, leading to faster Nixpkgs PR automation and CI velocity.

Skills preferred: Rust (OfBorg) or Haskell (nixpkgs-update)

Possible mentors:
- [@ryantm](https://github.com/ryan)

Rating:
medium

Prior efforts:
* https://discourse.nixos.org/t/nixtract-0-1-0-extract-graph-data-from-nix-code/34731
* https://github.com/NixOS/ofborg/blob/released/ofborg/src/outpaths.nix


### Testing and enhancing Dynamic Derivations

Existing work on an experimental feature known as "dynamic derivations", which refers to derivation outputs that can themselves be derivations, lacks the adequate testing to be upstreamed. Moreover, functionality can be added to this feature in order to enable "lang2nix" tools to act in a more seamless manner than they do now. 

The goal of this project is thus to thoroughly test this feature, in addition to adding new functionalities to it. Such functionalities include but are not limited to:

* Methods for converting foreign packages to Nix, such as with graphs for various package managers, we can also create conversion tools for Ninja and Make graphs. This could greatly benefit large builds like Chromium and LLVM.

* Additionally, determine a path for upstream tools like CMake, Meson, etc., to integrate with Nix. 

* We can also explore modifying language-specific package managers to utilize Nix for the actual building process.


Possible mentors:
 * [@DMills27](https://github.com/DMills27)
 * [@tomberek](https://github.com/tomberek)

Rating: Hard

References:

* https://github.com/NixOS/rfcs/blob/master/rfcs/0092-plan-dynamism.md
* https://github.com/NixOS/rfcs/pull/92
* https://github.com/NixOS/nix/issues/6316
### Nixpkgs: Build GCC libraries and compiler separately

This project aims to redo the way we build GCC so it is the same as LLVM:
build libraries separately from compiler, let Nixpkgs control the bootstrapping.
[Exherbo Linux](https://www.exherbolinux.org/) builds GCC in this way, so there is precedent.

Doing this will enable major simplifications in bootstrapping, cross compiling, cc-wrapper, etc.
These benefits however are fine to leave until after the GSOC project ends.

This is a very advanced project because it requires building a very old convoluted project (GCC) in ways that the upstream project doesn't anticipate.
The ability to be self-motivated, researching obscure error messages that few other people have encountered before, and generally trace issues to their *root* causes is required.
Being able to read GCC's source code, and potentially create patches (in C, C++, etc.) and upstream them is also a useful skill.

Possible mentors:
 - [@Ericson2314](https://github.com/Ericson2314)
 
 Rating: Hard


### Nixpkgs analytics: [`nixpkgs-review`](https://github.com/Mic92/nixpkgs-review) with a time-budget

This project is a small step in analyzing and understanding the data generated
by the Nixpkgs' fifteen years of modeling (bootstrapping, building and testing)
"much of the world of open source software". This data includes:

- [Hydra](https://hydra.nixos.org/job/nixpkgs/trunk/python311Packages.torch.aarch64-linux)'s evaluation errors, output paths, [build times](https://hydra.nixos.org/build/250198091#tabs-details), and build logs.
- The `.narinfo` files stored by https://cache.nixos.org, which together describe runtime dependency graphs between packages built by Hydra.
- Logs for the builds and `passthru` tests run by [Ofborg](https://logs.ofborg.org/).
- The [Nixpkgs](https://github.com/NixOS/nixpkgs) Git repository, where each
  revision includes Nix code that can be evaluated or built, as well as
  human-readable comments left by maintainers possibly providing insights into
  the evolution of coding patterns and conventions used by Nixpkgs, as well as
  into the details of upstream projects.
- The NixOS/Nixpkgs GitHub repository, which features conversations in GitHub issues and code reviews.
- IRC, Discourse, and Matrix logs.

Some of this data can be explored and visualized in Grafana hosted at https://monitoring.nixos.org/grafana.
This data allows tools like [nix-index](https://github.com/nix-community/nix-index/) (`nix-locate`, `comma`, [envfs](https://github.com/Mic92/envfs), etc.) to exist.
Nonetheless, we currently lack tools to use this data to (conveniently) answer
sometimes very simple queries like "how long has a given package been taking to
build on average". To contrast, our ambition could have been to reason about questions such as "how likely is the next build to succeed?", "how long is it likely to take until termination?", "given a Nixpkgs revision and a PR, what attributes is it likely to break?", "given Nixpkgs git history and a failing attribute, which commit is likely to have introduced the breakage?", "why was a given change introduced?". Some of these questions have brute-force solutions: termination times can be obtained by executing the builds, the offending commit may be found by bisection. The accumulated data offers us an opportunity to consult a model prior to performing the expensive computation.

In this project we'll attempt a modest task: write a version of [`nixpkgs-review`](https://github.com/Mic92/nixpkgs-review) or [`nix-fast-build`](https://github.com/Mic92/nix-fast-build) that can be given a time-budget to follow. The program would use historical data to estimate each package's contribution to the time complexity of the full review. The program would discard packages that "do not fit into the budget" and report their build status as "uncertain". When the observed build times deviate from the estimates, the program would dynamically adjust and schedule fewer or more builds as appropriate. The program would require a calibration procedure to attune to specific builders. Some sort of a simple linear model should suffice for the initial implementation.

Skills: the project might take understanding the codebase of [`nix-eval-jobs`](https://github.com/nix-community/nix-eval-jobs) and [`nix-fast-build`](https://github.com/Mic92/nix-fast-build) in order to learn how to control and schedule nix evaluation and builds; experience of working with data and the basic numerical sympathy would be helpful.

Rating: Medium

Possible mentors
- [@SomeoneSerge](https://github.com/SomeoneSerge/)
